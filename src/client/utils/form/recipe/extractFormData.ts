import type { Ingredient } from '@/common/types';

export interface ExtractedRecipeFormData {
    title: string;
    portionSize: number | null;
    time: number | null;
    imageUrl: string | null;
    notes: string | null;
    ingredients: Omit<Ingredient, 'id'>[];
    instructions: string[];
    tags: { id: number }[] | null;
}

/**
 * Parse the multipart <form> payload generated by RecipeForm component into
 * a structured object made for validation and API.
 */
export async function extractFormData(
    data: FormData
): Promise<ExtractedRecipeFormData> {
    const ingredientKeys = Array.from(data.keys()).filter((key) =>
        key.startsWith('ingredient-name')
    );

    const ingredients = ingredientKeys
        .map((key) => {
            const index = key.split('-')[2];
            const name =
                data
                    .get(`ingredient-name-${index}`)
                    ?.toString()
                    .toLowerCase()
                    .trim() || '';

            const quantity =
                (data.get(`ingredient-quantity-${index}`) as string) || null;
            const category =
                (data.get(`ingredient-category-${index}`) as string) || null;

            return {
                name,
                quantity,
                category: category && category.trim() ? category.trim() : null
            };
        })
        .filter((ingredient) => ingredient?.name && ingredient.name.length > 0);

    const instructionKeys = Array.from(data.keys()).filter((key) =>
        key.startsWith('instruction')
    );

    const instructions = instructionKeys
        .map((key) => data.get(key) as string)
        .filter((instruction) => instruction.length > 0);

    // Parse tags from hidden input (JSON encoded array of ids)
    const tagsRaw = (data.get('tags') as string | null) ?? null;
    let tags: { id: number }[] | null = null;

    if (tagsRaw) {
        try {
            const ids = JSON.parse(tagsRaw) as number[];
            if (Array.isArray(ids) && ids.length > 0) {
                tags = ids.map((id) => ({ id }));
            }
        } catch {
            // Ignore the error. This can only fail from parsing which should never happen. If it does,
            // let the recipe throught with empty tags, the user can edit them in afterwards.
        }
    }

    const imageFile = data.get('recipe-image') as File;
    const hasNewImageFile = imageFile && imageFile.size > 0;

    // If no new image file, check for default imageUrl in form data
    let imageUrl: string | null = null;
    if (!hasNewImageFile) {
        imageUrl = (data.get('imageUrl') as string) || null;
    }

    return {
        title: (data.get('title') as string) ?? '',
        portionSize: parseInt(data.get('portionSize') as string) || null,
        time: parseInt(data.get('time') as string) || null,
        imageUrl,
        notes: (data.get('notes') as string) ?? null,
        ingredients,
        instructions,
        tags
    };
}
